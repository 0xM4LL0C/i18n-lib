{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"i18n-lib","text":""},{"location":"#install","title":"install","text":""},{"location":"#from-pypi","title":"from PyPI","text":"<pre><code>pip install i18n-lib\n</code></pre>"},{"location":"#from-source","title":"from source","text":"<pre><code>pip install git+https://github.com/0xM4LL0C/i18n-lib.git\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#i18n.StringFormatter","title":"i18n.StringFormatter","text":"Source code in <code>src/i18n/formatter.py</code> <pre><code>class StringFormatter:\n    def __init__(self, global_context: dict[str, Any]) -&gt; None:\n        \"\"\"Initializes the StringFormatter with a global context.\n\n        Args:\n            global_context (dict[str, Any]): A dictionary containing global context variables.\n        \"\"\"\n        self.global_context = global_context\n        self.pattern = re.compile(r\"\\{([^{}]+)\\}\")\n\n    def _resolve_expr(self, expr: str, **kwargs: Any) -&gt; str:\n        \"\"\"Resolves an expression based on the context.\n\n        Args:\n            expr (str): The expression to resolve.\n            **kwargs: Additional context variables.\n\n        Returns:\n            str: The resolved expression or an error message if the expression cannot be resolved.\n        \"\"\"\n        ctx = ChainMap(kwargs, self.global_context)\n\n        if expr.startswith(\"func:\"):\n            return self._call_function(expr[5:], **kwargs)\n        if expr.startswith(\"obj:\"):\n            return self._get_object_attr(expr[4:], **kwargs)\n        if expr.startswith(\"const:\"):\n            return ctx.get(expr[6:], f\"[Error: const `{expr[6:]}` not defined]\")\n        return ctx.get(expr, f\"[Error: `{expr}` is not defined]\")\n\n    def _call_function(self, expr: str, **kwargs: Any) -&gt; str:\n        \"\"\"Calls a function based on the expression.\n\n        Args:\n            expr (str): The function expression to call.\n            **kwargs: Additional context variables.\n\n        Returns:\n            str: The result of the function call or an error message if the function cannot be called.\n        \"\"\"\n        ctx = ChainMap(kwargs, self.global_context)\n\n        match = re.fullmatch(r\"(\\w+)\\((.*)\\)\", expr)\n        if not match:\n            return f\"[Error: Expression '{expr}' does not match the expected pattern]\"\n\n        func_name, func_args = match.groups()\n\n        func: Optional[Callable[..., Any]] = ctx.get(func_name)\n\n        if not func:\n            return f\"[Error: func `{func_name}` is not defined]\"\n        if not callable(func):\n            return f\"[Error: `{func_name}` is not callable]\"\n        return str(eval(f\"{func_name}({func_args})\", dict(ctx), {}))\n\n    def _get_object_attr(self, expr: str, **kwargs: Any) -&gt; str:\n        \"\"\"Gets an object's attribute based on the expression.\n\n        Args:\n            expr (str): The object attribute expression to resolve.\n            **kwargs: Additional context variables.\n\n        Returns:\n            str: The value of the object's attribute or an error message if the attribute cannot be resolved.\n        \"\"\"\n        ctx = ChainMap(kwargs, self.global_context)\n        parts = expr.split(\".\")\n        obj_name = parts[0]\n\n        obj = ctx.get(obj_name)\n\n        if obj is None:\n            return f\"[Error: object `{obj_name}` is not defined]\"\n\n        return str(eval(expr, dict(ctx), {}))\n\n    def format(self, text: str, **kwargs: Any) -&gt; str:\n        \"\"\"Formats a string by replacing placeholders with context values.\n\n        Args:\n            text (str): The text containing placeholders to format.\n            **kwargs: Additional context variables.\n\n        Returns:\n            str: The formatted string with placeholders replaced by context values.\n        \"\"\"\n\n        def replace(match: re.Match[str]) -&gt; str:\n            return str(self._resolve_expr(match.group(1), **kwargs))\n\n        return self.pattern.sub(replace, text)\n</code></pre>"},{"location":"api/#i18n.StringFormatter.__init__","title":"i18n.StringFormatter.__init__","text":"<pre><code>__init__(global_context: dict[str, Any]) -&gt; None\n</code></pre> <p>Initializes the StringFormatter with a global context.</p> <p>Parameters:</p> Name Type Description Default <code>global_context</code> <code>dict[str, Any]</code> <p>A dictionary containing global context variables.</p> required Source code in <code>src/i18n/formatter.py</code> <pre><code>def __init__(self, global_context: dict[str, Any]) -&gt; None:\n    \"\"\"Initializes the StringFormatter with a global context.\n\n    Args:\n        global_context (dict[str, Any]): A dictionary containing global context variables.\n    \"\"\"\n    self.global_context = global_context\n    self.pattern = re.compile(r\"\\{([^{}]+)\\}\")\n</code></pre>"},{"location":"api/#i18n.StringFormatter._resolve_expr","title":"i18n.StringFormatter._resolve_expr","text":"<pre><code>_resolve_expr(expr: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Resolves an expression based on the context.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The expression to resolve.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional context variables.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The resolved expression or an error message if the expression cannot be resolved.</p> Source code in <code>src/i18n/formatter.py</code> <pre><code>def _resolve_expr(self, expr: str, **kwargs: Any) -&gt; str:\n    \"\"\"Resolves an expression based on the context.\n\n    Args:\n        expr (str): The expression to resolve.\n        **kwargs: Additional context variables.\n\n    Returns:\n        str: The resolved expression or an error message if the expression cannot be resolved.\n    \"\"\"\n    ctx = ChainMap(kwargs, self.global_context)\n\n    if expr.startswith(\"func:\"):\n        return self._call_function(expr[5:], **kwargs)\n    if expr.startswith(\"obj:\"):\n        return self._get_object_attr(expr[4:], **kwargs)\n    if expr.startswith(\"const:\"):\n        return ctx.get(expr[6:], f\"[Error: const `{expr[6:]}` not defined]\")\n    return ctx.get(expr, f\"[Error: `{expr}` is not defined]\")\n</code></pre>"},{"location":"api/#i18n.StringFormatter._call_function","title":"i18n.StringFormatter._call_function","text":"<pre><code>_call_function(expr: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Calls a function based on the expression.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The function expression to call.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional context variables.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The result of the function call or an error message if the function cannot be called.</p> Source code in <code>src/i18n/formatter.py</code> <pre><code>def _call_function(self, expr: str, **kwargs: Any) -&gt; str:\n    \"\"\"Calls a function based on the expression.\n\n    Args:\n        expr (str): The function expression to call.\n        **kwargs: Additional context variables.\n\n    Returns:\n        str: The result of the function call or an error message if the function cannot be called.\n    \"\"\"\n    ctx = ChainMap(kwargs, self.global_context)\n\n    match = re.fullmatch(r\"(\\w+)\\((.*)\\)\", expr)\n    if not match:\n        return f\"[Error: Expression '{expr}' does not match the expected pattern]\"\n\n    func_name, func_args = match.groups()\n\n    func: Optional[Callable[..., Any]] = ctx.get(func_name)\n\n    if not func:\n        return f\"[Error: func `{func_name}` is not defined]\"\n    if not callable(func):\n        return f\"[Error: `{func_name}` is not callable]\"\n    return str(eval(f\"{func_name}({func_args})\", dict(ctx), {}))\n</code></pre>"},{"location":"api/#i18n.StringFormatter._get_object_attr","title":"i18n.StringFormatter._get_object_attr","text":"<pre><code>_get_object_attr(expr: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Gets an object's attribute based on the expression.</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>str</code> <p>The object attribute expression to resolve.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional context variables.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The value of the object's attribute or an error message if the attribute cannot be resolved.</p> Source code in <code>src/i18n/formatter.py</code> <pre><code>def _get_object_attr(self, expr: str, **kwargs: Any) -&gt; str:\n    \"\"\"Gets an object's attribute based on the expression.\n\n    Args:\n        expr (str): The object attribute expression to resolve.\n        **kwargs: Additional context variables.\n\n    Returns:\n        str: The value of the object's attribute or an error message if the attribute cannot be resolved.\n    \"\"\"\n    ctx = ChainMap(kwargs, self.global_context)\n    parts = expr.split(\".\")\n    obj_name = parts[0]\n\n    obj = ctx.get(obj_name)\n\n    if obj is None:\n        return f\"[Error: object `{obj_name}` is not defined]\"\n\n    return str(eval(expr, dict(ctx), {}))\n</code></pre>"},{"location":"api/#i18n.StringFormatter.format","title":"i18n.StringFormatter.format","text":"<pre><code>format(text: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Formats a string by replacing placeholders with context values.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text containing placeholders to format.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional context variables.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted string with placeholders replaced by context values.</p> Source code in <code>src/i18n/formatter.py</code> <pre><code>def format(self, text: str, **kwargs: Any) -&gt; str:\n    \"\"\"Formats a string by replacing placeholders with context values.\n\n    Args:\n        text (str): The text containing placeholders to format.\n        **kwargs: Additional context variables.\n\n    Returns:\n        str: The formatted string with placeholders replaced by context values.\n    \"\"\"\n\n    def replace(match: re.Match[str]) -&gt; str:\n        return str(self._resolve_expr(match.group(1), **kwargs))\n\n    return self.pattern.sub(replace, text)\n</code></pre>"},{"location":"api/#i18n.I18N","title":"i18n.I18N","text":"<p>Internationalization class for managing translations.</p> Source code in <code>src/i18n/i18n.py</code> <pre><code>class I18N:\n    \"\"\"Internationalization class for managing translations.\"\"\"\n\n    def __init__(\n        self,\n        default_locale: str,\n        load_path: str = \"locales/\",\n    ) -&gt; None:\n        \"\"\"Initialize the I18N class.\n\n        Args:\n            default_locale (str): The default locale to use.\n            load_path (str, optional): The path to the directory containing locale files. Defaults to \"locales/\".\n        \"\"\"\n        self.load_path = load_path\n        self.default_locale = default_locale\n        self.loaded_translations: dict[str, dict[str, Any]] = {}\n        self.context: dict[str, Any] = {}\n        self.formatter = StringFormatter(self.context)\n\n        self.load()\n\n    def load(self) -&gt; None:\n        \"\"\"Load translations from locale files.\"\"\"\n        if not Path(self.load_path).exists():\n            self.loaded_translations = {}\n            return\n\n        for locale in Path(self.load_path).iterdir():\n            if locale.is_file() and locale.suffix in (\".yaml\", \".yml\"):\n                with locale.open(encoding=\"utf-8\") as f:\n                    self.loaded_translations[locale.stem] = yaml.safe_load(f) or {}\n\n    def _get_nested_translation(self, data: dict[str, Any], key: str) -&gt; Optional[str]:\n        \"\"\"Retrieve a nested translation from the data dictionary.\n\n        Args:\n            data (dict): The dictionary containing translations.\n            key (str): The key for the desired translation.\n\n        Returns:\n            Optional[str]: The nested translation or None if not found.\n        \"\"\"\n        keys = key.split(\".\")\n        for k in keys:\n            if isinstance(data, dict) and k in data:\n                data = data[k]\n            else:\n                return None\n        return data if isinstance(data, str) else None\n\n    def register_function(self, name: str, func: Callable[..., Any]) -&gt; None:\n        \"\"\"Register a custom function for use in translations.\n\n        Args:\n            name (str): The name of the function.\n            func (Callable): The function to register.\n        \"\"\"\n        self.context[name] = func\n\n    def register_constant(self, name: str, value: Any) -&gt; None:\n        \"\"\"Register a constant for use in translations.\n\n        Args:\n            name (str): The name of the constant.\n            value (Any): The value of the constant.\n        \"\"\"\n        self.context[name] = value\n\n    def t(self, locale: str, key: str, **kwargs: Any) -&gt; str:\n        \"\"\"Translate a key for a given locale.\n\n        Args:\n            locale (str): The locale to use for translation.\n            key (str): The key to translate.\n            **kwargs: Additional keyword arguments for formatting the translation.\n\n        Returns:\n            str: The translated string or the key if no translation is found.\n        \"\"\"\n        translation = (\n            self._get_nested_translation(self.loaded_translations.get(locale, {}), key)\n            or self._get_nested_translation(\n                self.loaded_translations.get(self.default_locale, {}), key\n            )\n            or key\n        )\n\n        if isinstance(translation, str):\n            return self.formatter.format(translation, **kwargs)\n\n        return key\n\n    @property\n    def available_locales(self) -&gt; set[str]:\n        \"\"\"Get the set of available locales.\n\n        Returns:\n            set[str]: The set of available locales.\n        \"\"\"\n        return set(self.loaded_translations.keys())\n</code></pre>"},{"location":"api/#i18n.I18N.available_locales","title":"i18n.I18N.available_locales  <code>property</code>","text":"<pre><code>available_locales: set[str]\n</code></pre> <p>Get the set of available locales.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: The set of available locales.</p>"},{"location":"api/#i18n.I18N.__init__","title":"i18n.I18N.__init__","text":"<pre><code>__init__(\n    default_locale: str, load_path: str = \"locales/\"\n) -&gt; None\n</code></pre> <p>Initialize the I18N class.</p> <p>Parameters:</p> Name Type Description Default <code>default_locale</code> <code>str</code> <p>The default locale to use.</p> required <code>load_path</code> <code>str</code> <p>The path to the directory containing locale files. Defaults to \"locales/\".</p> <code>'locales/'</code> Source code in <code>src/i18n/i18n.py</code> <pre><code>def __init__(\n    self,\n    default_locale: str,\n    load_path: str = \"locales/\",\n) -&gt; None:\n    \"\"\"Initialize the I18N class.\n\n    Args:\n        default_locale (str): The default locale to use.\n        load_path (str, optional): The path to the directory containing locale files. Defaults to \"locales/\".\n    \"\"\"\n    self.load_path = load_path\n    self.default_locale = default_locale\n    self.loaded_translations: dict[str, dict[str, Any]] = {}\n    self.context: dict[str, Any] = {}\n    self.formatter = StringFormatter(self.context)\n\n    self.load()\n</code></pre>"},{"location":"api/#i18n.I18N.load","title":"i18n.I18N.load","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load translations from locale files.</p> Source code in <code>src/i18n/i18n.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load translations from locale files.\"\"\"\n    if not Path(self.load_path).exists():\n        self.loaded_translations = {}\n        return\n\n    for locale in Path(self.load_path).iterdir():\n        if locale.is_file() and locale.suffix in (\".yaml\", \".yml\"):\n            with locale.open(encoding=\"utf-8\") as f:\n                self.loaded_translations[locale.stem] = yaml.safe_load(f) or {}\n</code></pre>"},{"location":"api/#i18n.I18N._get_nested_translation","title":"i18n.I18N._get_nested_translation","text":"<pre><code>_get_nested_translation(\n    data: dict[str, Any], key: str\n) -&gt; Optional[str]\n</code></pre> <p>Retrieve a nested translation from the data dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary containing translations.</p> required <code>key</code> <code>str</code> <p>The key for the desired translation.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The nested translation or None if not found.</p> Source code in <code>src/i18n/i18n.py</code> <pre><code>def _get_nested_translation(self, data: dict[str, Any], key: str) -&gt; Optional[str]:\n    \"\"\"Retrieve a nested translation from the data dictionary.\n\n    Args:\n        data (dict): The dictionary containing translations.\n        key (str): The key for the desired translation.\n\n    Returns:\n        Optional[str]: The nested translation or None if not found.\n    \"\"\"\n    keys = key.split(\".\")\n    for k in keys:\n        if isinstance(data, dict) and k in data:\n            data = data[k]\n        else:\n            return None\n    return data if isinstance(data, str) else None\n</code></pre>"},{"location":"api/#i18n.I18N.register_function","title":"i18n.I18N.register_function","text":"<pre><code>register_function(\n    name: str, func: Callable[..., Any]\n) -&gt; None\n</code></pre> <p>Register a custom function for use in translations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the function.</p> required <code>func</code> <code>Callable</code> <p>The function to register.</p> required Source code in <code>src/i18n/i18n.py</code> <pre><code>def register_function(self, name: str, func: Callable[..., Any]) -&gt; None:\n    \"\"\"Register a custom function for use in translations.\n\n    Args:\n        name (str): The name of the function.\n        func (Callable): The function to register.\n    \"\"\"\n    self.context[name] = func\n</code></pre>"},{"location":"api/#i18n.I18N.register_constant","title":"i18n.I18N.register_constant","text":"<pre><code>register_constant(name: str, value: Any) -&gt; None\n</code></pre> <p>Register a constant for use in translations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the constant.</p> required <code>value</code> <code>Any</code> <p>The value of the constant.</p> required Source code in <code>src/i18n/i18n.py</code> <pre><code>def register_constant(self, name: str, value: Any) -&gt; None:\n    \"\"\"Register a constant for use in translations.\n\n    Args:\n        name (str): The name of the constant.\n        value (Any): The value of the constant.\n    \"\"\"\n    self.context[name] = value\n</code></pre>"},{"location":"api/#i18n.I18N.t","title":"i18n.I18N.t","text":"<pre><code>t(locale: str, key: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Translate a key for a given locale.</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>str</code> <p>The locale to use for translation.</p> required <code>key</code> <code>str</code> <p>The key to translate.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for formatting the translation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The translated string or the key if no translation is found.</p> Source code in <code>src/i18n/i18n.py</code> <pre><code>def t(self, locale: str, key: str, **kwargs: Any) -&gt; str:\n    \"\"\"Translate a key for a given locale.\n\n    Args:\n        locale (str): The locale to use for translation.\n        key (str): The key to translate.\n        **kwargs: Additional keyword arguments for formatting the translation.\n\n    Returns:\n        str: The translated string or the key if no translation is found.\n    \"\"\"\n    translation = (\n        self._get_nested_translation(self.loaded_translations.get(locale, {}), key)\n        or self._get_nested_translation(\n            self.loaded_translations.get(self.default_locale, {}), key\n        )\n        or key\n    )\n\n    if isinstance(translation, str):\n        return self.formatter.format(translation, **kwargs)\n\n    return key\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#020---2025-03-27","title":"[0.2.0] - 2025-03-27","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added new <code>StringFormatter</code> class in <code>i18n/formatter.py</code> for handling string formatting logic</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Refactored <code>I18N</code> class to use new <code>StringFormatter</code> for string formatting</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed string formatting error handling</li> </ul>"},{"location":"changelog/#010---2025-03-18","title":"[0.1.0] - 2025-03-18","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>This documentation provides a detailed explanation of how to use the I18N class for internationalization (i18n) in your Python projects. The I18N class allows you to manage translations, constants, and functions, and dynamically inject them into your translated strings.</p>"},{"location":"usage/#initializing-the-i18n-instance","title":"Initializing the I18N Instance","text":"<p>Create an instance of the I18N class by specifying the default locale and the path where your translation files are located:</p> <pre><code>from i18n import I18N\n\ni18n = I18N(default_locale=\"en\", load_path=\"locales/\")\n</code></pre>"},{"location":"usage/#registering-constants","title":"Registering Constants","text":"<p>You can register constants that can be used in your translations. Constants are static values that do not change during runtime.</p> <pre><code>i18n.register_const(\"CONST_VAR\", \"some value\")\n</code></pre>"},{"location":"usage/#registering-functions","title":"Registering Functions","text":"<p>You can also register functions that can be called dynamically within your translations. Functions can take arguments and return values that are injected into the translated strings.</p>"},{"location":"usage/#translating-strings","title":"Translating Strings","text":"<p>To translate a string, use the t method of the I18N instance. The t method takes the locale, the translation key, and any additional keyword arguments that will be used in the translation.</p> <pre><code>print(i18n.t(\"en\", \"greet\", name=\"Jake\"))  # Output: \"hello Jake\"\nprint(i18n.t(\"en\", \"with-const\"))  # Output: \"with const: some value\"\nprint(i18n.t(\"en\", \"with-func\"))  # Output: \"with func call: Alex\"\nprint(i18n.t(\"en\", \"func-with-args\"))  # Output: \"func call with args: 2\"\nprint(i18n.t(\"en\", \"with-obj\", object=SomeObject))  # Output: \"with object attribute: some value\"\n</code></pre>"},{"location":"usage/#translation-file-structure","title":"Translation File Structure","text":"<pre><code>greet: hello {name}\nwith-const: \"with const: {const:CONST_VAR}\"\nwith-func: \"with func call: {func:get_name()}\"\nfunc-with-args: \"func call with args: {func:add(1, 1)}\"\nwith-obj: \"with object attribute: {obj:object.some_attribute}\"\n</code></pre>"},{"location":"usage/#fallback-to-default-locale","title":"Fallback to Default Locale","text":"<p>If a translation key is not found in the specified locale, the I18N class will fall back to the default locale:</p> <pre><code>print(i18n.t(\"fr\", \"greet\", name=\"Jake\"))  # Output: \"hello Jake\" (fallback to \"en\" locale)\n</code></pre>"},{"location":"usage/#handling-missing-keys","title":"Handling Missing Keys","text":"<p>If a translation key is missing in both the specified locale and the default locale, the t method will return the key itself:</p> <pre><code>print(i18n.t(\"en\", \"missing_key\"))  # Output: \"missing_key\"\n</code></pre>"}]}